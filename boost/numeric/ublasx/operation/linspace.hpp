/* vim: set tabstop=4 expandtab shiftwidth=4 softtabstop=4: */

/**
 * \file boost/numeric/ublasx/operation/linspace.hpp
 *
 * \brief Linearly spaced vector
 *
 * Inspired by MATLAB's linspace function.
 *
 * \author Marco Guazzone (marco.guazzone@gmail.com)
 *
 * <hr/>
 *
 * Copyright (c) 2013, Marco Guazzone
 * 
 * Distributed under the Boost Software License, Version 1.0. (See
 * accompanying file LICENSE_1_0.txt or copy at
 * http://www.boost.org/LICENSE_1_0.txt)
 */

#ifndef BOOST_NUMERIC_UBLASX_OPERATION_LINSPACE_HPP
#define BOOST_NUMERIC_UBLASX_OPERATION_LINSPACE_HPP


#include <boost/numeric/ublas/exception.hpp>
#include <boost/numeric/ublas/vector.hpp>
#include <cstddef>


namespace boost { namespace numeric { namespace ublasx {

using namespace ::boost::numeric::ublas;

/**
 * \brief Generates a linearly spaced vector.
 *
 * Generates \a n values linearly spaced between \a a and \a b.
 * Note, in case \f$a<b\f$, generates a decreasing sequence.
 *
 * Inspired by MATLAB's linspace function.
 *
 * \param a The starting value of the linearly spaced sequence.
 * \param b The final value of the linearly spaced sequence.
 * \param n The number of values to generate
 * \return A vector of linearly spaced values in \f$[a,b]\f$; if
 *  <code>n=1</code>, returns \a b.
 *
 * \author Marco Guazzone (marco.guazzone@gmail.com)
 */
template <typename ValueT>
BOOST_UBLAS_INLINE
vector<ValueT> linspace(ValueT a, ValueT b, std::size_t n = 100)
{
    // pre: n > 0
    BOOST_UBLAS_CHECK( n > 0,
                       bad_argument() );

    if (n < 2)
    {
        return scalar_vector<ValueT>(1, b);
    }

    vector<ValueT> x(n);

    --n;

    // Check for possible overflows generated by opposite signs
    const ValueT c = (b-a)*(n-1);
    if (std::isinf(c) && std::isinf(b-a))
    {
        // Overflows is happened => split computations

        const ValueT an = a/n;
        const ValueT bn = b/n;

        for (std::size_t i = 0; i <= n; ++i)
        {
            x[i] = a + bn*i - an*i;
        }
    }
    else
    {
        // No overflow

        const ValueT step = (b-a)/n;

        for (std::size_t i = 0; i <= n; ++i)
        {
            x[i] = a + step*i;
        }
    }

    // just make sure that endpoints are honored
    x[0] = a;
    x[n] = b;

    return x;
}

}}} // Namespace boost::numeric::ublasx


#endif // BOOST_NUMERIC_UBLASX_OPERATION_LINSPACE_HPP
